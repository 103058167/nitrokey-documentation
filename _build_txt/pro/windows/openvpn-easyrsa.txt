Configurazione di OpenVPN con Easy-RSA

(Nitrokey Pro 2 - Windows)

Prerequisiti

Lato server  1. Installare OpenVPN  2. Installare Easy-RSA  3. Creare
una PKI per il server OpenVPN  4. Creare server.req e ``server.key`
5. Firmare e recuperare server.crt  6. Configura il server OpenVPN  7.
Avvia il servizio OpenVPN sul server

Configurazione lato client  1. Installare OpenVPN e Easy-RSA  2.
Creare una PKI per il client OpenVPN  3. Creare un client.req e
``client.key`  4. Firmare client.req ed emettere il file ``client.crt`
5. Importare client.crt sulla Nitrokey dalla macchina CA  6.
Recuperare il file chain.crt dalla macchina CA  7. Configurare il
client per interagire con Nitrokey  8. Avviare il client OpenVPN

Nota: Questa guida è work-in-progress, e sarà aggiornata di
  conseguenza. Si prega di prendere in considerazione questo stato.

Questa guida mostra come configurare i client OpenVPN per effettuare
il login utilizzando una

Nitrokey Pro 2

 o una

Nitrokey Storage 2

. Per la gestione delle chiavi software useremo

Easy-RSA

, una utility che si è evoluta insieme a OpenVPN.

Per firmare i certificati, useremo un

Nitrokey HSM 2

 impostato come

Certificate Authority

, tuttavia questa guida non copre la configurazione della CA stessa (è
chiara e ` ben documentata qui <certificate-authority.html#sign-a
-server-certificate>`_).

Useremo Easy-RSA, perché sembra fornire una certa flessibilità e
permette la gestione delle chiavi tramite PKI esterne. Lo useremo sul
server per emettere la richiesta di firma, e ripeteremo lo stesso
processo sul client. Le richieste di firma dei certificati saranno
firmate dalla CA sull'HSM Nitorkey, e ritrasmesse al server e al
client.

Prerequisiti

Nella seguente documentazione avremo bisogno di 3 macchine diverse
come segue:

Server OpenVPN (v. 2.5) su Debian 10 (macchina virtuale EC2 - AWS)

Client OpenVPN (v. 2.4.9) su Fedora 30 (macchina locale)

L'Autorità di Certificazione sarà accessibile da una macchina
standalone con Fedora 30 (macchina locale)

Per interagire con i dispositivi avremo bisogno di ` OpenSC 0.20 <

https://github.com/OpenSC/OpenSC/wiki

>`_ installato sulla macchina client e CA (le macchine locali). Potete
seguire le istruzioni per impostarlo in ` questo link (>>*<<Unix) <

https://github.com/OpenSC/OpenSC/wiki/Compiling-and-Installing-on-
Unix-flavors

>`_.

Per scaricare le dipendenze sulle macchine Fedora possiamo seguire
questa istruzione:

   su -c 'dnf install readline-devel openssl-devel libxslt docbook-style-xsl pcsc-lite-devel automake autoconf libtool gcc zlib-devel'

Per Debian Linux, pacchetti OpenSC più recenti sono disponibili ` qui
<

https://github.com/Nitrokey/opensc-build

>`_.

Useremo le seguenti Nitrokeys per la gestione delle chiavi fisiche:

Una chiave di autenticazione utilizzando la Nitrokey Pro 2 (pdf)

Un'Autorità di Certificazione (CA) che utilizza il Nitrokey HSM 2
(pdf)

Come promemoria, per costruire una Certificate Authority su Nitrokey
HSM 2, potete seguire le istruzioni disponibili ` nella documentazione
<certificate-authority.html#sign-a-server-certificate>`_.

In alternativa si può impostare la propria CA su una ` su una macchina
separata <

https://www.digitalocean.com/community/tutorials/how-to-set-up-and-
configure-a-certificate-authority-ca-on-ubuntu-20-04

>`_, o usare il tutorial OpenVPN che si basa anche su

Easy-RSA

. Le ultime 2 opzioni si basano su soluzioni software per la gestione
delle chiavi.


Lato server

1. Installare OpenVPN

Per prima cosa dobbiamo abilitare l'inoltro IP modificando il file
/etc/sysctl.conf

   $ editor /etc/sysctl.conf

Togliere il commento o modificare di conseguenza la seguente linea

   net.ipv4.ip_forward=1

Chiudi dopo averlo salvato e inserisci questo comando

   $ sysctl -p

Una volta fatto l'IP forwarding, dovremo scaricare l'ultima versione
di OpenvPN per il nostro server Debian 10, secondo

queste istruzioni

:

Passare a root e scaricare la chiave GPG che ha firmato il pacchetto

   $ sudo -s
   # wget -O - https://swupdate.openvpn.net/repos/repo-public.gpg|apt-key add -

Aggiungere l'URL dei pacchetti OpenVPN adeguati al file sources.list

   # echo "deb http://build.openvpn.net/debian/openvpn/release/2.5 buster main" > /etc/apt/sources.list.d/openvpn-aptrepo.list
   # exit

Abbiamo scaricato OpenVPN 2.5 in quanto il "password prompt" richiede
almeno OpenVPN ` versione 2.4.8 <

https://community.openvpn.net/openvpn/ticket/1215

>`_ per il login.

Poi scarichiamo OpenVPN

   $ sudo apt install openvpn

Se volete controllare la versione, è possibile chiamando "--version" e
stampare quanto segue:

   $ sudo openvpn --version
   OpenVPN 2.5_beta3 x86_64-pc-linux-gnu [SSL (OpenSSL)] [LZO] [LZ4] [EPOLL] [PKCS11] [MH/PKTINFO] [AEAD] built on Sep  1 2020
   library versions: OpenSSL 1.1.1d 10 Sep 2019, LZO 2.10
   Originally developed by James Yonan
   Copyright (C) 2002-2018 OpenVPN Inc <sales@openvpn.net>
   Compile time defines: enable_async_push=no enable_comp_stub=no enable_crypto_ofb_cfb=yes enable_debug=yes enable_def_auth=yes enable_dependency_tracking=no \ enable_dlopen=unknown enable_dlopen_self=unknown enable_dlopen_self_static=unknown enable_fast_install=needless enable_fragment=yes enable_iproute2=yes \ enable_libtool_lock=yes enable_lz4=yes enable_lzo=yes enable_maintainer_mode=no enable_management=yes enable_multihome=yes enable_pam_dlopen=no enable_pedantic=no \ enable_pf=yes enable_pkcs11=yes enable_plugin_auth_pam=yes enable_plugin_down_root=yes enable_plugins=yes enable_port_share=yes enable_selinux=no \ enable_shared=yes enable_shared_with_static_runtimes=no enable_silent_rules=no enable_small=no enable_static=yes enable_strict=no enable_strict_options=no \ enable_systemd=yes enable_werror=no enable_win32_dll=yes enable_x509_alt_username=yes with_aix_soname=aix with_crypto_library=openssl with_gnu_ld=yes \ with_mem_check=no with_sysroot=no

2. Installare Easy-RSA

Per costruire la PKI, scaricheremo l'ultima versione di Easy-RSA sulle
macchine server e client. Per ottenere l'ultima versione, andate alla
pagina

Releases sul progetto ufficiale EasyRSA GitHub

, copiate il link di download del file che termina con ".tgz", e poi
incollatelo nel seguente comando:

Scarica l'ultima versione

   $ cd ~
   wget -P ~/ https://github.com/OpenVPN/easy-rsa/releases/download/v3.0.7/EasyRSA-3.0.7.tgz

Estrarre il tarball

   $ cd ~
   $ tar xvf EasyRSA-3.0.7.tgz
   $ mv EasyRSA-3.0.7/ easyrsa/ # rename folder

3. Creare una PKI per il server OpenVPN

Prima di poter creare la chiave privata e il certificato del tuo
server OpenVPN, è necessario creare una directory locale Public Key
Infrastructure sul tuo server OpenVPN. Userai questa directory per
gestire le richieste di certificati del server e dei client, invece di
farle direttamente sul tuo server CA.

Per costruire una directory PKI sul tuo server OpenVPN, dovrai
popolare un file chiamato "vars" con alcuni valori predefiniti.

Creare un file vars

   $ touch ~/easyrsa/vars
   $ cd easyrsa/
   $ editor vars

Una volta aperto il file, incollate le due righe seguenti

   set_var EASYRSA_ALGO "ec"
   set_var EASYRSA_DIGEST "sha512"

Queste sono le uniche due linee di cui hai bisogno in questo file
"vars" sul tuo server OpenVPN poiché non sarà utilizzato come Autorità
di Certificazione. Essi garantiranno che le tue chiavi private e le
richieste di certificati siano configurate per utilizzare la
crittografia a curva ellittica (ECC) per generare chiavi e firme
sicure per i tuoi client e il server OpenVPN.

Per quanto riguarda la scelta degli algoritmi crittografici, seguo il
modello in ` questo tutorial <

https://www.digitalocean.com/community/tutorials/how-to-set-up-and-
configure-an-openvpn-server-on-centos-8

>`_, e potete personalizzarli secondo le vostre esigenze specifiche.

Inizializzare la PKI

Una volta che avete popolato il file "vars" potete procedere con la
creazione della directory PKI. Per farlo, esegui lo script easyrsa con
l'opzione init-pki:

   $ ./easyrsa init-pki

Dopo aver inizializzato la tua PKI sul server OpenVPN, sei pronto a
passare al passo successivo, che è la creazione di una richiesta di
certificato del server OpenVPN e della chiave privata.

4. Creare server.req e ``server.key`

Ora che il tuo server OpenVPN ha tutti i prerequisiti installati, il
prossimo passo è quello di generare una coppia di chiavi composta da
una chiave privata (da mantenere segreta), e un Certificate Signing
Request (".csr") sul tuo server OpenVPN.

In termini generali, sui sistemi in cui generiamo una chiave e una
richiesta, questi file sono lasciati in chiaro usando l'argomento
"nopass", poiché i server di solito devono avviarsi senza alcun
inserimento di password. Questo genera una

chiave non criptata

, quindi si consiglia di

proteggere attentamente i suoi permessi di accesso e di file

.

Suggerimento: Note di configurazione di OpenVPN:

  Il server, e ogni client, deve avere il proprio file cert e key. Il
  server e tutti i client useranno lo stesso file CA.

  Il certificato del server dovrebbe avere le seguenti
  caratteristiche:

  keyUsage:  digitalSignature, keyEncipherment

  extendedKeyUsage: serverAuth

Creare la richiesta di firma per il server

Naviga nella directory "~/easyrsa" sul tuo Server OpenVPN come utente
non-root, e inserisci i seguenti comandi:

   $ cd easyrsa/
   $ ./easyrsa gen-req server nopass

Questo creerà una chiave privata per il server e un file di richiesta
di certificato chiamato "server.req".

Una volta che hai un certificato firmato, lo trasferirai di nuovo al
server OpenVPN.

Copiare la chiave nella directory del server OpenVPN

   $ sudo cp /home/admin/EasyRSA/pki/private/server.key /etc/openvpn/server/

Dopo aver completato questi passi, hai creato con successo una chiave
privata per il tuo server OpenVPN. Hai anche generato una Certificate
Signing Request per il server OpenVPN.

Suggerimento: Estensioni dei file per le richieste di firma dei
  certificatiL'estensione del file adottata dal tutorial CA e HSM
  indica la creazione di un file ".csr", tuttavia Easy-RSA crea
  richieste di firma di certificati con un'estensione ".req".Useremo
  in modo intercambiabile entrambe le estensioni, assicurandoci di
  trasferire i file giusti all'Autorità di Certificazione, e di
  generare un certificato finale con estensione ".crt".

Nella prossima sezione di questa guida, firmeremo un file ".req" con
la nostra CA distribuita sul dispositivo HSM 2. Per questo scopo,
userò una macchina dedicata per firmare le richieste.

5. Firmare e recuperare server.crt

Le seguenti istruzioni richiedono il trasferimento del file
"server.req" (o "server.csr") al sistema CA.

Il trasferimento in sé non è sensibile alla sicurezza, anche se è
saggio verificare se il file ricevuto corrisponde alla copia del
mittente, se il trasporto non è affidabile.

Per passare attraverso questi passi, mi baserò ampiamente su ` queste
istruzioni <certificate-authority.html#creating-the-intermediate-
certificate-authority>`_, per firmare le richieste di firma del
certificato, una volta che le abbiamo generate con Easy-RSA.

5.1. Firmare il file server.req

Sulla macchina locale dedicata all'accesso all'HSM, useremo gli
strumenti forniti da Opensc 0.20 per firmare il file ".req", e
rimandarlo al server OpenVPN. Supponiamo di aver trasferito il file
dalla macchina server alla macchina CA.

Per prima cosa iniziamo a collegare l'HSM Nitrokey, e inseriamo questa
istruzione per elencare le chiavi disponibili.

Interrogare l'elenco dei dispositivi disponibili

     $ p11tool --list-all

   **(Required step)** If this is the first time you sign a certificate with the CA, you might want to retrieve the URI of the CA’s private key from the HSM, and include it in the config file.

L'URI della chiave dovrebbe essere in questo formato:

   pkcs11:model=PKCS%2315%20emulated;manufacturer=www.CardContact.de;serial=DENK0104068;token=SmartCard-HSM%20%28UserPIN%29%00%00%00%00%00%00%00%00%00;id=%E0%16%1C%C8%B6%F5%D6%6A%C6%83%5E%CD%EC%B6%23%FC%05%06%A6%75;object=root;type=private

Creare openvpn/ directory sotto certificate-authority/

   $ mkdir/opt/certificate-authority/
   $ cd /opt/certificate-authority/

Firma il server.req

   $ openssl ca -config sign_server_csrs.ini -engine pkcs11 -keyform engine -days 375 -notext -md sha512 -create_serial -in server.req -out /home/user/pki/issued/server.crt

5.2. Recuperare il file server.crt sulla macchina server

Trasferire i certificati firmati al server

Dalla macchina CA, copiare i file "server.crt" e "chain.crt" sul
server OpenVPN. In questo esempio useremo il comando "scp" come segue:

   $ scp openvpn/{server.crt,chain.crt} admin@your_openvpnserver_ip:/tmp

Mettere i certificati nella directory del server

   $ mv /tmp/{server.crt,chain.crt} /etc/openvpn/server

Avvertimento: Certificato CA e "chain.crt"Nel caso precedente, la CA
  restituisce il certificato sever firmato, e include il certificato
  CA "CA.crt" che è il file "chain.crt". Questo può essere fatto su un
  canale insicuro, anche se il client è incoraggiato a confermare se
  il "chain.crt" ricevuto è valido, se il trasporto non è affidabile.È
  possibile rinominare il file "chain.crt" in "CA.crt" sulla macchina
  target, tuttavia useremo "chain.crt" nelle prossime istruzioni.

6. Configura il server OpenVPN

Una connessione che usa TLS richiede più ` certificati e chiavi di
autenticazione <

https://wiki.teltonika-
networks.com/view/OpenVPN_configuration_examples

>`_. Ora che li abbiamo emessi e firmati, possiamo metterli nelle
giuste directory. La ripartizione dei certificati e delle chiavi che
devono trovarsi nella directory principale è la seguente:

   OpenVPN server

       - The root certificate file (CA.crt or chain.crt in our setup)
       - Server certificate
       - Server key
       - Diffie Hellman Parameters (optional)

Sul tuo server OpenVPN, ora puoi creare il file di configurazione
"server.conf" con il tuo editor di testo preferito. Il file può essere
configurato secondo le tue esigenze, mentre noi ci assicuriamo di
cambiare il certificato del server e le sezioni delle chiavi secondo i
nomi che hai scelto per i tuoi file firmati:

   # OpenVPN Server Certificate - CA, server key and certificate
   ca chain.crt
   cert server.crt
   key server.key

Ecco il file di configurazione che possiamo usare per testare queste
istruzioni:

   port 1194
   proto udp
   dev tun
   ca ca.crt
   cert server.crt
   key server.key  # This file should be kept secret
   dh dh.pem
   server 10.8.0.0 255.255.255.0
   push "redirect-gateway def1 bypass-dhcp"
   push "dhcp-option DNS 208.67.222.222"
   push "dhcp-option DNS 208.67.220.220"
   keepalive 10 120
   tls-auth ta.key 0 # This file is secret
   cipher AES-256-CBC
   user nobody
   group nogroup
   persist-key
   persist-tun
   status /var/log/openvpn/openvpn-status.log
   log         /var/log/openvpn/openvpn.log
   log-append  /var/log/openvpn/openvpn.log
   verb 3
   explicit-exit-notify 1
   tls-version-min 1.2 # Lower boundary for TLS version
   tls-version-max 1.2 # Higher boundary for TLS version

Per testare se la configurazione funziona correttamente, possiamo
usare questo comando:

   $ sudo openvpn --server --config server.conf

7. Avvia il servizio OpenVPN sul server

Abilita il servizio OpenVPN aggiungendolo a systemctl, e avvialo
usando questi comandi:

   $ sudo systemctl -f enable openvpn@server
   $ sudo systemctl start openvpn@server

Per controllare due volte se il servizio OpenVPN è attivo usa questo
comando:

   $ sudo systemctl status openvpn@server

A questo punto OpenVPN dovrebbe essere in esecuzione.


Configurazione lato client

   1. Install OpenVPN and Easy-RSA
   2. Create a Public Key Infrastructure (PKI) for the OpenVPN client
   3. Create the client's certificate signing request and the client's key
   4. Sign and issue the client's certificate
   5. Import the client certificate on the Nitrokey from the CA machine
   6. Retrieve the chain certificate from the CA machine
   7. Configure the client to interact with the Nitrokey
   8. Start the OpenVPN client

1. Installare OpenVPN e Easy-RSA

Installare il software

Possiamo usare direttamente "dnf install" per installare OpenVPN 2.4.9
e Easy-RSA 3.0.7

   $ sudo dnf install openvpn easy-rsa

Poi creiamo come non-root una directory per Easy RSA chiamata Easy-RSA

   $ mkdir ~/easyrsa

E collegarlo al pacchetto Easy RSA che abbiamo appena installato

   $ ln -s /usr/share/easy-rsa/3/* ~/easyrsa/

2. Creare una PKI per il client OpenVPN

Nello stesso modo in cui abbiamo creato una PKI sul server OpenVPN,
creeremo una PKI usando Easy-RSA sul lato client.

3. Creare un client.req e ``client.key`

Nello stesso modo in cui abbiamo emesso la coppia di chiavi sul sever,
generiamo una coppia di chiavi per il client che sarà composta dal
file "client.req" e dal file "client.key". Quest'ultimo deve essere
tenuto segreto sulla macchina client.

4. Firmare client.req ed emettere il file ``client.crt`

Per trasferire il file "client.req" alla macchina CA, useremo lo
stesso metodo che abbiamo fatto per il file "server.req".

Una volta trasferito, sulla macchina della CA firmiamo il file di
richiesta di firma del certificato con questo comando

   $ openssl ca -config sign_server_csrs.ini -engine pkcs11 -keyform engine -days 375 -notext -md sha512 -create_serial -in client.req -out /home/user/pki/issued/client.crt

5. Importare client.crt sulla Nitrokey dalla macchina CA

Dopo aver creato il file "client.crt", inseriamo il dispositivo
Nitrokey Pro 2 nella macchina CA, e importiamo il ".crt" nel
dispositivo Pro 2 usando questo comando:

   $ pkcs15-init --store-certificate client.crt --id 3

Potete vedere se la chiave è effettivamente memorizzata sulla Nitrokey
usando questo comando:

   $ pkcs15-tool -c

O in alternativa

   $ pkcs11-tool --list-objects

Per ulteriori comandi si può fare riferimento al ` wiki di OpenSC <

https://github.com/OpenSC/OpenSC/wiki/OpenPGP-card

>`_.

6. Recuperare il file chain.crt dalla macchina CA

Mentre teniamo il file "client.crt"stored on the nitrokey Pro 2
device, we must retrieve the "chain.crt" sulla macchina client, e lo
memorizziamo nella directory adeguata. Possiamo usare "scp" come nel
metodo spiegato nella sezione server di questa guida.

7. Configurare il client per interagire con Nitrokey

Ora, tornati sulla macchina client, collegheremo la Nitrokey Pro e la
useremo per stabilire la connessione VPN con il server. In termini
generali, una connessione che utilizza TLS richiede più certificati e
chiavi per l'autenticazione:

   OpenVPN client
       - The root certificate file (`chain.crt`)
       - Client certificate
       - Client key

Per questa guida possiamo il seguente file "client.conf", e aggiungere
le opzioni richieste di conseguenza:

   client
   dev tun
   proto udp
   remote <server> 1194
   resolv-retry infinite
   nobind
   user nobody
   group nobody
   persist-key
   persist-tun
   ca ca.crt
   remote-cert-tls server
   cipher AES-256-CBC
   verb 3
   redirect-gateway def1
   tls-version-min 1.2 # Lower boundary for TLS version
   tls-version-max 1.2 # Higher boundary for TLS version

Determinare l'oggetto corretto

Ogni fornitore PKCS#11 può supportare più dispositivi. Per
visualizzare l'elenco degli oggetti disponibili si può usare il
seguente comando:

   $ openvpn --show-pkcs11-ids /usr/lib64/pkcs11/opensc-pkcs11.so

   The following objects are available for use.
   Each object shown below may be used as parameter to

   --pkcs11-id option please remember to use single quote mark.

   Certificate
          DN:             CN=client
          Serial:         E53DA75C5B8F1518F520BCEF0128C09F
          Serialized id:  pkcs11:model=pkcs11:model=PKCS%NNNN%20emulated;token=User%20PIN%20%28OpenPGP%20card%29;manufacturer=ZeitControl;serial=000NNNNNN;id=%03

Ogni coppia certificato/chiave privata ha una stringa unica
"Serialized id". La stringa id serializzata del certificato richiesto
dovrebbe essere specificata nel file di configurazione. Possiamo farlo
aggiungendo l'opzione "pkcs11-id" usando virgolette singole.

   pkcs11-id 'pkcs11:model=pkcs11:model=PKCS%NNNN%20emulated;token=User%20PIN%20%28OpenPGP%20card%29;manufacturer=ZeitControl;serial=000NNNNNN;id=%03'

Aggiungere l'ID serializzato recuperato al file di configurazione

Usando il vostro editor di testo preferito, aprite il file server.conf
e aggiungete le seguenti righe, avendo cura di inserire le vostre
"Serialized id":

   pkcs11-providers /usr/lib64/pkcs11/opensc-pkcs11.so
   pkcs11-id 'pkcs11:model=pkcs11:model=PKCS%NNNN%20emulated;token=User%20PIN%20%28OpenPGP%20card%29;manufacturer=ZeitControl;serial=000NNNNNN;id=%03'

Per ulteriori

impostazioni relative all'autenticazione OpenVPN

, si possono anche aggiungere alcune righe per gestire la gestione
delle chiavi, sebbene sia opzionale.

Nota: Clicca per visualizzare il codice

     # nitrokey config

     pkcs11-providers /usr/lib64/pkcs11/opensc-pkcs11.so
     pkcs11-id 'pkcs11:model=pkcs11:model=PKCS%NNNN%20emulated;token=User%20PIN%20%28OpenPGP%20card%29;manufacturer=ZeitControl;serial=000NNNNNN;id=%03'
     # pkcs11-pin-cache 300
     # daemon
     # auth-retry nointeract
     # management-hold
     # management-signal
     # management 127.0.0.1 8888
     # management-query-passwords
     pkcs11-cert-private 1 # Prompt for PIN

Passo opzionale

Se avete bisogno di testare la configurazione, con e senza il token
sulla Nitrokey, potete aggiungere linee allo stesso "client.conf" e
commentare/commentare le linee pertinenti secondo le vostre esigenze:

Nota: Clicca per visualizzare il codice

     # non_nitrokey login

     # cert client.crt
     # key client.key
     # tls-auth ta.key 1

Configurare il client OpenVPN

Il file di configurazione finale "client.conf" dovrebbe essere come
questo:

   client
   dev tun
   proto udp
   remote <server> 1194
   resolv-retry infinite
   nobind
   user nobody
   group nobody
   persist-key
   persist-tun
   ca ca.crt
   remote-cert-tls server
   cipher AES-256-CBC
   verb 3
   redirect-gateway def1
   tls-version-min 1.2 # Lower boundary for TLS version
   tls-version-max 1.2 # Higher boundary for TLS version

   # nitrokey login

   pkcs11-providers /usr/lib64/pkcs11/opensc-pkcs11.so
   pkcs11-id 'pkcs11:model=pkcs11:model=PKCS%NNNN%20emulated;token=User%20PIN%20%28OpenPGP%20card%29;manufacturer=ZeitControl;serial=000NNNNNN;id=%03'
   # pkcs11-pin-cache 300
   # daemon
   # auth-retry nointeract
   # management-hold
   # management-signal
   # management 127.0.0.1 8888
   # management-query-passwords
   pkcs11-cert-private 1 # Prompt for PIN

   # OR

   # non_nitrokey login

   # cert client.crt
   # key client.key
   # tls-auth ta.key 1

Problemi noti

Ci sono alcuni problemi noti relativi al login di OpenVPN con OpenSC.
Si prega di consultare questi problemi ` qui <

https://github.com/Nitrokey/wiki/wiki/3rd-Party-Issues

>`_.

8. Avviare il client OpenVPN

Avviare il servizio OpenVPN sul client

Abilita il servizio OpenVPN e avvialo usando questi comandi:

   $ sudo systemctl -f enable openvpn-server@server.service
   $ sudo systemctl start openvpn-server@server.service

Per controllare due volte se il servizio OpenVPN è attivo usa questo
comando:

   $ sudo systemctl status openvpn-server@server.service

Inserisci il tuo PIN utente

Quando si esegue il client OpenVPN, il PIN di Nitrokey deve essere
inserito:

   $ sudo openvpn --client --config client.conf
   Fri Sep 11 17:42:01 2020 OpenVPN 2.4.9 x86_64-redhat-linux-gnu [SSL (OpenSSL)] [LZO] [LZ4] [EPOLL] [PKCS11] [MH/PKTINFO] [AEAD] built on Apr 24 2020
   Fri Sep 11 17:42:01 2020 library versions: OpenSSL 1.1.1g FIPS  21 Apr 2020, LZO 2.08
   Fri Sep 11 17:42:01 2020 PKCS#11: Adding PKCS#11 provider '/usr/lib64/pkcs11/opensc-pkcs11.so'
   Enter User PIN (OpenPGP card) token Password: ******

Unfortunately OpenVPN doesn’t seem to be able to establish a handshake
and stops at an error as reported

here

,

here

 and

here

Avvertimento: uscita errore"$ sudo openvpn --client --config
  client.conf" "Fri Sep 11 17:42:01 2020 OpenVPN 2.4.9 x86_64-redhat-
  linux-gnu [SSL (OpenSSL)] [LZO] [LZ4] [EPOLL] [PKCS11] [MH/PKTINFO]
  [AEAD] built on Apr 24 2020" "Fri Sep 11 17:42:01 2020 library
  versions: OpenSSL 1.1.1g FIPS  21 Apr 2020, LZO 2.08" "Fri Sep 11
  17:42:01 2020 PKCS#11: Adding PKCS#11 provider
  '/usr/lib64/pkcs11/opensc- pkcs11.so'" "Enter User PIN (OpenPGP
  card) token Password: ******" "Fri Sep 11 17:42:12 2020 TCP/UDP:
  Preserving recently used remote address:
  [AF_INET]18.157.180.240:1194" "Fri Sep 11 17:42:12 2020 Socket
  Buffers: R=[212992->212992] S=[212992->212992]" "Fri Sep 11 17:42:12
  2020 UDP link local: (not bound)" "Fri Sep 11 17:42:12 2020 UDP link
  remote: [AF_INET]18.157.180.240:1194" "Fri Sep 11 17:42:12 2020
  NOTE: UID/GID downgrade will be delayed because of --client, --pull,
  or --up-delay" "Fri Sep 11 17:42:12 2020 TLS: Initial packet from
  [AF_INET]18.157.180.240:1194, sid=d79690cf 9e38ce89" "Fri Sep 11
  17:42:12 2020 VERIFY OK: depth=1, CN=server_CA" "Fri Sep 11 17:42:12
  2020 VERIFY KU OK" "Fri Sep 11 17:42:12 2020 Validating certificate
  extended key usage" "Fri Sep 11 17:42:12 2020 ++ Certificate has EKU
  (str) TLS Web Server Authentication, expects TLS Web Server
  Authentication" "Fri Sep 11 17:42:12 2020 VERIFY EKU OK" "Fri Sep 11
  17:42:12 2020 VERIFY OK: depth=0, CN=server" "Fri Sep 11 17:42:12
  2020 OpenSSL: error:141F0006:SSL
  routines:tls_construct_cert_verify:EVP lib" "Fri Sep 11 17:42:12
  2020 TLS_ERROR: BIO read tls_read_plaintext error" "Fri Sep 11
  17:42:12 2020 TLS Error: TLS object -> incoming plaintext read
  error" "Fri Sep 11 17:42:12 2020 TLS Error: TLS handshake failed"
  "Fri Sep 11 17:42:12 2020 SIGUSR1[soft,tls-error] received, process
  restarting" "Fri Sep 11 17:42:12 2020 Restart pause, 5 second(s)"

In alcuni casi segnalati non richiede il PIN sul terminale. Una
soluzione potrebbe essere quella di usare questo comando per accedere
con il PIN:

   $ telnet 8888 password 'User PIN (OpenPGP card) token' <PIN>

In alternativa, potresti ` ricompilare il client OpenVPN <

https://forums.openvpn.net/viewtopic.php?f=4&t=23318

>`_ con il supporto systemd disabilitato, e ti chiederà il PIN come
previsto.

Un'altra opzione, sarebbe quella di accedere alla tua istanza OpenVPN
con il client Viscosity che fornisce una migliore esperienza utente
soprattutto per l'inserimento del PIN.
